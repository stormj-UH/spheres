# spheres
This uses a 3d-embedding of the sphere and some lower precision floating points to calculate great circles. The error seems to be more than you'd get just from not using a GIS-spheroid and instead using the perfect sphere, but not quite by an order of magnitude. One of the algorithms does a better job, but as I left it only calculates the short path between the two locations and not the entire great circle.
There are better ways to display the CSV files, but this library did the job to check it out. I also tried using arbitrary precision libraries, but to wring any further precision out of it, I'd need to go to an oblate spheroid model and re-do most of the math.
I could never quite get an intrinsic geometry to work, where we would just solve the DEs for lat/long as we moved along in the natural coordinates preserving curvature equal to the radius. Since I never got that working on a sphere, I obviously never got it going on an oblate spheroid.
Flying too close to the poles (the singularities) gives errors and distortions that really should be manageable. This might be the math library in general, but I think it's the cross-product routine, that seems to be where we lose a lot of precision based on some A/B testing with the arbitrary precision library, but I never ran that to ground because I lost steam on this before I was able to find a next step that made sense.
Upgrading the geometry was probably the right next step, but it seemed like there was something else keeping things between 5-10 times, but usually about 5 times, more error than that. I tried the arbitrary precision library, but the linear algebra got tricky with the cross product. I could not really get a good way to use intrinsic geometry that didn't just end up losing more precision.
So, this is what I've got. It does a decent enough job.
